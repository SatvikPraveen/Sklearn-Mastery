"""Utility decorators for performance monitoring and debugging."""

import time
import functools
import psutil
import os
from typing import Callable, Any, Optional, Dict
import warnings
from pathlib import Path
import pickle
import hashlib
import json

from ..config.logging_config import get_logger


def timing_decorator(func: Callable) -> Callable:
    """Decorator to measure function execution time.
    
    Args:
        func: Function to decorate.
        
    Returns:
        Decorated function that logs execution time.
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger = get_logger('timing')
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.info(f"{func.__name__} executed in {execution_time:.4f} seconds")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"{func.__name__} failed after {execution_time:.4f} seconds: {e}")
            raise
    
    return wrapper


def memory_usage_decorator(func: Callable) -> Callable:
    """Decorator to monitor memory usage during function execution.
    
    Args:
        func: Function to decorate.
        
    Returns:
        Decorated function that logs memory usage.
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger = get_logger('memory')
        
        # Get memory usage before
        process = psutil.Process(os.getpid())
        memory_before = process.memory_info().rss / 1024 / 1024  # MB
        
        try:
            result = func(*args, **kwargs)
            
            # Get memory usage after
            memory_after = process.memory_info().rss / 1024 / 1024  # MB
            memory_diff = memory_after - memory_before
            
            logger.info(f"{func.__name__} memory usage: {memory_before:.1f}MB -> {memory_after:.1f}MB "
                       f"(+{memory_diff:+.1f}MB)")
            
            return result
            
        except Exception as e:
            memory_after = process.memory_info().rss / 1024 / 1024  # MB
            memory_diff = memory_after - memory_before
            logger.error(f"{func.__name__} failed with memory usage: {memory_before:.1f}MB -> {memory_after:.1f}MB "
                        f"(+{memory_diff:+.1f}MB): {e}")
            raise


def save_plots_decorator(
    filename_prefix: str = None,
    subfolder: str = None,
    formats: list = None,
    auto_close: bool = True
) -> Callable:
    """Decorator to automatically save plots generated by a function.
    
    Args:
        filename_prefix: Prefix for saved filenames.
        subfolder: Subfolder to save plots in.
        formats: List of formats to save ['png', 'pdf', 'svg'].
        auto_close: Whether to close figures after saving.
        
    Returns:
        Decorated function that saves any matplotlib figures created.
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            import matplotlib.pyplot as plt
            from ..utils.helpers import VisualizationUtils
            
            logger = get_logger('plots')
            
            # Get current figures before function execution
            initial_figures = set(plt.get_fignums())
            
            try:
                # Execute the function
                result = func(*args, **kwargs)
                
                # Get new figures created during execution
                final_figures = set(plt.get_fignums())
                new_figures = final_figures - initial_figures
                
                if new_figures:
                    # Determine filename prefix
                    prefix = filename_prefix or func.__name__
                    
                    # Save each new figure
                    saved_count = 0
                    for i, fig_num in enumerate(sorted(new_figures)):
                        fig = plt.figure(fig_num)
                        
                        # Create filename
                        if len(new_figures) > 1:
                            filename = f"{prefix}_{i+1:02d}"
                        else:
                            filename = prefix
                        
                        # Save figure
                        try:
                            saved_paths = VisualizationUtils.save_figure(
                                fig, filename, subfolder=subfolder, formats=formats or ['png']
                            )
                            saved_count += 1
                            
                            # Close figure if requested
                            if auto_close:
                                plt.close(fig)
                                
                        except Exception as e:
                            logger.error(f"Failed to save figure {fig_num}: {e}")
                    
                    logger.info(f"Saved {saved_count} figures from {func.__name__}")
                
                return result
                
            except Exception as e:
                logger.error(f"Function {func.__name__} failed: {e}")
                raise
        
        return wrapper
    return decorator


def cache_results(
    cache_dir: Optional[str] = None,
    use_hash: bool = True,
    expire_hours: Optional[int] = None
) -> Callable:
    """Decorator to cache function results to disk.
    
    Args:
        cache_dir: Directory to store cache files.
        use_hash: Whether to use argument hash for cache key.
        expire_hours: Hours after which cache expires.
        
    Returns:
        Decorated function with caching capability.
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            logger = get_logger('cache')
            
            # Set up cache directory
            if cache_dir is None:
                cache_path = Path("results/cache")
            else:
                cache_path = Path(cache_dir)
            cache_path.mkdir(parents=True, exist_ok=True)
            
            # Generate cache key
            if use_hash:
                # Create hash from function name and arguments
                func_signature = f"{func.__name__}_{str(args)}_{str(sorted(kwargs.items()))}"
                cache_key = hashlib.md5(func_signature.encode()).hexdigest()
            else:
                cache_key = func.__name__
            
            cache_file = cache_path / f"{cache_key}.pkl"
            
            # Check if cache exists and is valid
            if cache_file.exists():
                try:
                    # Check expiration
                    if expire_hours is not None:
                        file_age = time.time() - cache_file.stat().st_mtime
                        if file_age > expire_hours * 3600:
                            logger.info(f"Cache expired for {func.__name__}")
                            cache_file.unlink()
                        else:
                            # Load from cache
                            with open(cache_file, 'rb') as f:
                                result = pickle.load(f)
                            logger.info(f"Loaded {func.__name__} result from cache")
                            return result
                    else:
                        # Load from cache (no expiration)
                        with open(cache_file, 'rb') as f:
                            result = pickle.load(f)
                        logger.info(f"Loaded {func.__name__} result from cache")
                        return result
                        
                except Exception as e:
                    logger.warning(f"Failed to load cache for {func.__name__}: {e}")
                    cache_file.unlink()  # Remove corrupted cache
            
            # Execute function and cache result
            try:
                result = func(*args, **kwargs)
                
                # Save to cache
                with open(cache_file, 'wb') as f:
                    pickle.dump(result, f)
                
                logger.info(f"Cached result for {func.__name__}")
                return result
                
            except Exception as e:
                logger.error(f"Function {func.__name__} failed: {e}")
                raise
        
        return wrapper
    return decorator